#!/usr/bin/perl

# use strict;
# use warnings;

# Check for an alternate tools library path for testing
my $_test_alt_tools_lib;
my $_test_alt_bench_lib;
BEGIN {
	my $_pbench_tspp_dir = $ENV{'pbench_tspp_dir'};
	$_test_alt_tools_lib=$ENV{_TEST_ALTERNATE_TOOLS_LIBRARY};
	if (not defined $_test_alt_tools_lib or not -d $_test_alt_tools_lib) {
		$_test_alt_tools_lib = "$_pbench_tspp_dir";
	}
	my $_pbench_bspp_dir = $ENV{'pbench_bspp_dir'};
	$_test_alt_bench_lib=$ENV{_TEST_ALTERNATE_BENCH_LIBRARY};
	if (not defined $_test_alt_bench_lib or not -d $_test_alt_bench_lib) {
		$_test_alt_bench_lib = "$_pbench_bspp_dir";
	}
}
use lib "$_test_alt_tools_lib";
use lib "$_test_alt_bench_lib";
no lib ".";
use GenData qw(gen_data);
use BenchPostprocess qw(get_mean remove_timestamp get_timestamps write_influxdb_line_protocol get_cpubusy_series calc_ratio_series calc_sum_series div_series);
use File::Basename;
use Data::Dumper;
use List::Util('sum');
use JSON;

sub mean {
	if ( scalar @_ > 0 ) {
		return sum(@_)/@_;
	} else {
		return 0;
	}
}

my $script = basename($0);
my $dir = $ARGV[0];
my $protocol = $ARGV[1];
my $message_size = int $ARGV[2];
my $instances = int $ARGV[3];
my $test_type = $ARGV[4];
my $clients = $ARGV[5];
my $servers = $ARGV[6];
my $tool_label_pattern = $ARGV[7];
my $tool_group = $ARGV[8];
my $benchmark_version = $ARGV[9];
my %uperf_sample;
my %uperf_rate;
my $timestamp_ms = 0;
my $prev_timestamp_ms = 0;
my $timestamp_ms_diff;
my $line;
my %avg;
my %total;
my $port_label = 'port';
my $uid_label = 'uid';
my $description_label = 'description';
my $role_label = 'role';
my $hostname_label = 'hostname';
my $client_hostname_label = 'client_' . $hostname_label;
my $server_hostname_label = 'server_' . $hostname_label;
my $server_port_label = 'server_port';
my $value_label = 'value';
my $timeseries_label = 'timeseries';
my $date_label = 'date';

if ($test_type =~ /rr/) {
	$uperf_primary_metric="trans_sec";
} else {
	$uperf_primary_metric="Gb_sec";
}
# %workload
#		   {Throughput|Latency|Resource|Efficiency}
#		   {Throughput}[Gb_sec, 

my %workload;  # root hash for all data, contains hash refs to
		# %throughput, %latency, %resource, %efficiency
my %parameters;	# a hash of parameter-type:array-of-parameter-values

my @benchmark;	# each array element contains a hash with paramters
		# for this benchmark:
		# message-size-bytes: 256
		# protocol: tcp
		# instances: 4
		# test-type: stream

my %resource;	# a hash of resource-type:array-of-resource-values,

my @cpu_busy;	# each array element contains a hash with
		# hostname: hostname or IP
		# role: client, server, host, kvm-host, container-host, etc.
		# timeseries: a hash of timestamp:value key-pairs
my %efficiency;
my %latency;    # a hash of throughput-type:array-of-throughput-values,
		# for example $throughput{Gb_sec[0..1]
my @usec;	# each array element contains a hash with:
	    	# hostname: <hostname or IP>
	    	# role: <client or server> <-uperf happens to always be client
	    	# timeseries: a hash of timstamp:value elements

my %throughput; # a hash of throughput-type:array-of-throughput-values,
		# for example $throughput{Gb_sec[0..1]
my @Gb_sec;	# each array element contains a hash with:
	    	# hostname: <hostname or IP>
	    	# role: <client or server> <-uperf happens to always be client
	    	# timeseries: a hash of timstamp:value key-pairs
my @trans_sec;	# each array element contains a hash with:
	    	# hostname: <hostname or IP>
	    	# role: <client or server> <-uperf happens to always be client
	    	# timeseries: a hash of timstamp:value key-pair

my %benchmark_parameters_dataset = ( 'name' => uperf, 'version' => $benchmark_version, 'test-type' => $test_type, 'protocol' => $protocol, 'message-size-bytes' => $message_size, 'instances' => $instances, 'clients' => $clients, 'servers' => $servers );
push(@benchmark, \%benchmark_parameters_dataset);

# Get the tool data
# Define a set of tool directories which we want to use to report CPU and efficiency metrics
# Search for tool directories which match the $tool_label_pattern
my %tool_ids;
my $tool_group_dir = "$dir/tools-$tool_group";
if (opendir(my $dh, $tool_group_dir)) {
	my $this_tool_dir;
	foreach $this_tool_dir (readdir($dh)) {
		if ($this_tool_dir =~ /^$tool_label_pattern/) {
			my $tool_dir_id = $this_tool_dir;
			$tool_dir_id =~ s/^$tool_pattern_label//;
			$this_tool_dir = $tool_group_dir . "/" . $this_tool_dir;
			$tool_ids{$this_tool_dir} = $tool_dir_id;
		}
	}
} else {
	print "$script: could not find any directories in $tool_group_dir which matched $tool_label_pattern\n";
}
foreach $this_tool_dir (keys %tool_ids) {
	my $res;
	my $this_tool_id = $tool_ids{$this_tool_dir};
	my $role = "host";
	my $url;
	my $hostname;
	($role, $hostname) = split(/:/,$this_tool_id);
	my @cpubusy_samples;
	$res = get_cpubusy_series($this_tool_dir, \@cpubusy_samples );
	if ( $res == 0 ) {
		my %this_cpubusy_dataset;
		my $description = "Total busy CPU usage, averaged over N seconds, where 1.0 = 1 logical CPU";
		my $mean = get_mean(\@cpubusy_samples);
		my $uid = "host::%" . $hostname_label . "%"; 
		%this_cpubusy_dataset = ( $uid_label => $uid, $description_label => $description, $role_label => $role, $hostname_label => $hostname, $value_label => $mean, $timeseries_label => \@cpubusy_samples);
		push(@cpu_busy, \%this_cpubusy_dataset);
		#write_influxdb_line_protocol("cpubusy", $influx_dir, \%this_cpubusy_dataset);
	}
}
if ( @cpu_busy ) {
	$resource{'cpu_busy'} = \@cpu_busy;
}

# Load the data from uperf output and create throughput metrics
# There can be several result files, once for each server involved in this test
# These are organized by server IP:port.
#print "going to read dir: [$dir]\n";
opendir(my $dh, $dir) || die "$script: could not open directory $dir: $!\n";
my $nr_result_files=0;

foreach $result_file ( readdir($dh) ) {
	# for each result file, build this:
	# # {
	# # "hostname": "perf104", <-where this workload was running
	# # "role": "client", <-where this information came from: workload client or server
	# # "samples" : {1407890808: 7.75, 1407890809: 7.77}  <-time series data from workload output
	# # "average" : "7.76" <-the average of the time series data
	# # },
	# the server ip should be in the result file name, like "result-192.168.1.1.txt"
	if ( $result_file =~ /^client::(.+)-server::(.+):(\d+)--client_output\.txt$/) {
		my $client_hostname = $1;
		my $server_hostname = $2;
		my $server_port = int $3;
		my $identifier = "client::" . $client_hostname . "-server::" . $server_hostname . ":" . $server_port;
		my $role = "client";
		my $average;
		my @throughput_samples;
		my @latency_samples;

		$this_nr_bytes_label = "bytes-" . $identifier; # a number of bytes (not a througput metric)
		$this_nr_ops_label = "ops-" . $identifier; # a number of operations
		$this_tput_label = "Gb_sec-_" . $identifier; # a number of bytes over time
		$this_opssec_label = "ops_sec-" . $identifier; # a number of operations over time
		$this_transsec_label = "trans_sec-" . $identifier; # a number of transactions over time
		$this_lat_label = "usec-" . $identifier; # a time period
		open(IN_FILE, "$dir/$result_file") || die "$script: could not open file $dir/$result_file: $!\n";
		$prev_timestamp_ms = 0;
		while (<IN_FILE>) {
			$line = "$_";
			chomp($line);

			# for each sample in the uperf result file, we get a number of bytes and a timestamp
			# example of a sample: "time:1395170796.1234 name:Txn2 nr_bytes:22037790720 nr_ops:43042560"
			if ( $line =~  /^timestamp_ms:(\d+)\.\d+\s+name:Txn2\s+nr_bytes:(\d+)\s+nr_ops:(\d+)/ ) {
				$timestamp_ms = $1;
				$bytes = $2;
				$ops = $3;
				$uperf_sample{$this_nr_ops_label}{$timestamp_ms} = $ops;
				$uperf_sample{$this_nr_bytes_label}{$timestamp_ms} = $bytes;
	 			$timestamp_s_diff = ($timestamp_ms - $prev_timestamp_ms)/1000;
				$nr_bytes_diff = $uperf_sample{$this_nr_bytes_label}{$timestamp_ms} - $uperf_sample{$this_nr_bytes_label}{$prev_timestamp_ms};
				$nr_ops_diff = $uperf_sample{$this_nr_ops_label}{$timestamp_ms} - $uperf_sample{$this_nr_ops_label}{$prev_timestamp_ms};
				if ( $nr_ops_diff == 0) {
					next;
				}
				if ( $prev_timestamp_ms != 0 ) {
					# This is what we are really interested in: computing value/sec metrics like Gb/sec and ops/sec
					# We can do that once we have more than one sample
					# store the "rate" metrics
					if ($test_type =~ /rr/) {
						$ops_sec = $nr_ops_diff /$timestamp_s_diff;
						$trans_sec = $ops_sec /2;
						# for request-response, 1 transaction is two ops, a write and a read.
						$uperf_rate{"uperf"}{"Throughput"}{$this_transsec_label}{$timestamp_ms} = $ops_sec /2;
						$throughput_samples{$timestamp_ms} = $ops_sec /2;
						# the latency is the full round trip for 1 transaction, which is also = ($instances / trans_sec)
						# if --log-response-times in pbench_uperf is used, the write and read latency can be computed (later).
						$uperf_rate{"uperf"}{"Latency"}{$this_lat_label}{$timestamp_ms} = $instances /$trans_sec *1000000;
						my %latency_sample = ( 'date' => int $timestamp_ms, 'value' => $instances /$trans_sec *1000000);
						push(@latency_samples, \%latency_sample);
						my %throughput_sample = ('date' => int $timestamp_ms, 'value' => $trans_sec);
						push(@throughput_samples, \%throughput_sample);
					} else {
						$bytes_sec = $nr_bytes_diff /$timestamp_s_diff;
						$uperf_rate{"uperf"}{"Throughput"}{$this_tput_label}{$timestamp_ms} = $nr_bytes_diff *8 /1000000000 /$timestamp_s_diff;
						my %throughput_sample = ('date' => int $timestamp_ms, 'value' => ($nr_bytes_diff *8 /1000000000 /$timestamp_s_diff));
						push(@throughput_samples, \%throughput_sample);
					}
				}
				$prev_timestamp_ms = $timestamp_ms;
			}
		}
		$nr_result_files++;
		close(IN_FILE);
		# the uid should be unique
		my $uid = "client::%" . $client_hostname_label . "%-server::%" . $server_hostname_label . "%:%" . $server_port_label . "%";
		if ( (@latency_samples) ) {
			my %this_lat_dataset;
			my $description = "Average elapsed time spanning: client sending, server accepting/sending, and client receiving 1 message, over a 1 second window";
			my $mean = get_mean(\@latency_samples);
			%this_lat_dataset = ( $uid_label => $uid, $description_label => $description, $role_label => $role, $client_hostname_label => $client_hostname, $server_hostname_label => $server_hostname, $server_port_label => int $server_port, $value_label => $mean, $timeseries_label => \@latency_samples);
			push(@usec, \%this_lat_dataset);
		}
		if ( (@throughput_samples) ) {
			my %this_tput_dataset;
			if ($test_type =~ /rr/) {
				my $description = "Number of transactions sent by client for a period of 1 second";
				my $mean = get_mean(\@throughput_samples);
				%this_tput_dataset = ( $uid_label => $uid, $description_label => $description, $role_label => $role, $client_hostname_label => $client_hostname, $server_hostname_label => $server_hostname, $server_port_label => int $server_port, $value_label => $mean, $timeseries_label => \@throughput_samples);
				push(@trans_sec, \%this_tput_dataset);
			} else {
				my $description = "Number of gigabits sent by client for a period of 1 second";
				my $mean = get_mean(\@throughput_samples);
				%this_tput_dataset = ( $uid_label => $uid, $description_label => $description, $role_label => $role, $client_hostname_label => $client_hostname, $server_hostname_label => $server_hostname, $server_port_label => int $server_port, $value_label => $mean, $timeseries_label => \@throughput_samples);
				push(@Gb_sec, \%this_tput_dataset);
			}
		}
	}
}
closedir $dh;
if ($nr_result_files == 0) {
	print "$script: could not find any result files to process, exiting\n";
	exit;
}
# construct what we have so far in a master workload hash
if ( @Gb_sec ) {
	$throughput{'Gb_sec'} = \@Gb_sec;
}
if ( @trans_sec ) {
	$throughput{'trans_sec'} = \@trans_sec;
}
if ( @usec ) {
	$latency{'usec'} = \@usec;
}
if ( @benchmark ) {
	$parameters{'benchmark'} = \@benchmark;
}
if ( %throughput ) {
	$workload{'throughput'} = \%throughput;
}
if ( %latency ) {
	$workload{'latency'} = \%latency;
}
if ( %resource ) {
	$workload{'resource'} = \%resource;
}
if ( %parameters ) {
	$workload{'parameters'} = \%parameters;
}
		
# process any data in %workload{'throughput'|'latency'}, aggregating various per-client results
my $metric_class;
foreach $metric_class ('throughput', 'latency') {
	my $metric_type;
	foreach $metric_type (keys %{ $workload{$metric_class} }) {
		my %aggregate_dataset; # a new dataset for aggregated results
		$aggregate_dataset{$description_label} = $workload{$metric_class}{$metric_type}[0]{$description_label};
		$aggregate_dataset{$role_label} = "aggregate";
		$aggregate_dataset{$client_hostname_label} = "all";
		$aggregate_dataset{$server_hostname_label} = "all";
		$aggregate_dataset{$server_port_label} = "all";
		$aggregate_dataset{$uid_label} = "client::%" . $client_hostname_label . "%-server::%" . $server_hostname_label . "%:%" . $server_port_label . "%";
		# use the same timstamps from the first data
		@ref_timestamps = get_timestamps(\@{ $workload{$metric_class}{$metric_type}[0]{$timeseries_label}});
		my @aggregate_samples;
		# our new timeseries array for aggregate starts off with 0s
		foreach $timestamp_ms (@ref_timestamps) {
			my %aggregate_sample = ( $date_label => int $timestamp_ms, $value_label => 0);
			push(@aggregate_samples, \%aggregate_sample);
		}
		# And now we add the values from each per server result to that hash one at a time
		my $i;
		for ($i=0; $i < scalar @{ $workload{$metric_class}{$metric_type} }; $i++) {
			calc_sum_series(\@{ $workload{$metric_class}{$metric_type}[$i]{$timeseries_label} }, \@aggregate_samples);
		}
		if ( $metric_class eq 'latency' ) {
			div_series(\@aggregate_samples, $i);
		}
		$aggregate_dataset{$value_label} = get_mean(\@aggregate_samples);
		$aggregate_dataset{$timeseries_label} = \@aggregate_samples;
		# The aggregate data should be the first in the array
		unshift(@{ $workload{$metric_class}{$metric_type} }, \%aggregate_dataset);
	}
}

my $json_file = $dir . "/result.json";
my $json_text   = to_json( \%workload, { ascii => 1, pretty => 1 } );
open(JSON, ">$json_file") || die "$script: could not open file $json_file: $!\n";
print JSON $json_text;
close(JSON);

# if there is a request-response test , and there is a log of the response times, process it.
my $all_server_write_avg_time;
my $all_server_read_avg_time;
my $all_server_nr_reads = 0;
my $all_server_nr_writes = 0;
my @all_server_transaction_times;
my $nr_resp_files = 0;
opendir(my $dh, $dir) || die "$script: can't open directory $dir: $!\n";
foreach $resp_file ( readdir($dh) ) {
	if ( $resp_file =~ /^response-times-(.+).txt$/) {
		$server_ip = $1;
		# The server ip should be in the file name, like "response-times-192.168.1.1.txt"
		open(RESP_FILE, "$dir/$resp_file") || die "$script: can't open file $dir/$resp_file: $!\n";
		#printf "$script: processing %s\n", $resp_file;
		#  This response file contains an elapsed time value for each "flow op" in the 5th column:
		#  35609 140172276365056  0 1408072771750861084           42765
		#  For request-response, 2 lines contain the two values: first the request (a write) and next a response (a read).
		#  The write is usually very fast, as it's just the write to the socket and should return almost immediately.
		#  The read is the time for the packet to be sent out, responded by the other system, sent back, and read by the
		#  uperf process.
		$line = <RESP_FILE>; # this first value is the time it takes to open the stream
		# the following lines will have a pattern of write (send) then read (receive)
		my $time_us;
		my $time_ns;
		my $read_time;
		my $write_time;
		my @this_server_transaction_times;
		my $transaction_time;
		my $this_server_write_avg_time;
		my $this_server_read_avg_time;
		my $this_server_nr_reads;
		my $this_server_nr_writes;
		my $resp_type = "write"; # the remaining values are times alternating between two flow ops: a write (send a request) and a read (wait for response)
		while ($line = (<RESP_FILE>)) {
			#  35609 140172276365056  0 1408072771750861084           42765
			$line =~ /\s*\d+\s+\d+\s+\d+\s+\d+\s+(\d+)/;
			$time_ns = $1;
			# print "time_ns: $time_ns\n";
			$time_us = $time_ns / 1000;
			if ($resp_type eq "write") {
				$write_time = $time_us;
				$all_server_write_avg_time += $write_time;
				$this_server_write_avg_time += $write_time;
				$all_server_nr_writes++;
				$this_server_nr_writes++;
				# the next value will be for a read
				$resp_type = "read";
				next;
			}
			if ($resp_type eq "read") {
				$read_time = $time_us;
				$all_server_read_avg_time += $read_time;
				$this_server_read_avg_time += $read_time;
				$all_server_nr_reads++;
				$this_server_nr_reads++;
				push(@this_server_transaction_times, ($write_time + $read_time));
				push(@all_server_transaction_times, ($write_time + $read_time));
				# the next value will be for a write
				$resp_type = "write";
				next;
			}
		}
		close RESP_FILE;
		$nr_resp_files++;
		@this_server_transaction_times = sort {$a <=> $b} @this_server_transaction_times;
		$this_server_read_avg_time /= $this_server_nr_reads;
		$this_server_write_avg_time /= $this_server_nr_writes;
		printf "resp-file: $resp_file\n";
		printf "average latency: %.4f\n", ($this_server_read_avg_time + $this_server_write_avg_time);
		printf "95th percentile latency: %.4f\n", $this_server_transaction_times[sprintf("%.0f",(0.95*($#this_server_transaction_times)))];
		printf "99.995th percentile latency: %.4f\n", $this_server_transaction_times[sprintf("%.0f",(0.99995*($#this_server_transaction_times)))];
		printf "maximum latency: %.4f\n", $this_server_transaction_times[$#this_server_transaction_times];
	}
}
if ($nr_resp_files > 0) {
	@all_server_transaction_times = sort {$a <=> $b} @all_server_transaction_times;
	$all_server_write_avg_time /= $all_server_nr_writes;
	$all_server_read_avg_time /= $all_server_nr_reads;
	my $filename = $dir . "/summary-response-times.txt";
	open(RESP_SUMMARY, ">$filename") || die "$script: could not open $filename\n";
	printf RESP_SUMMARY "Number of writes: %d  Average response time for writes is: %.4fus\n", $all_server_nr_writes, $all_server_write_avg_time;
	printf RESP_SUMMARY "Number of reads: %d  Average response time for reads is: %.4fus\n", $all_server_nr_reads, $all_server_read_avg_time;
	printf RESP_SUMMARY "Average transaction latency: %.4fus\n", ($all_server_read_avg_time + $all_server_write_avg_time);
	printf RESP_SUMMARY "95th percentile transaction latency: %.4fus\n", $all_server_transaction_times[sprintf("%.0f",(0.95*($#all_server_transaction_times)))];
	printf RESP_SUMMARY "99.995th percentile transaction latency: %.4fus\n", $all_server_transaction_times[sprintf("%.0f",(0.99995*($#all_server_transaction_times)))];
	printf RESP_SUMMARY "Maximum transaction latency: %.4fus\n", $all_server_transaction_times[$#all_server_transaction_times];
	close(RESP_SUMMARY);
	$total{"write_latency_us"} = $all_server_write_avg_time;
	$total{"read_latency_us"} = $all_server_read_avg_time;
}

# define the graph types
# if you want something other than lineChart, put it here
my %graph_type;

# threshold for displying a series in a graph
my %graph_threshold;

# N.B. Final parameter of 1 tells gen_data to do the expensive
# combinatorial check of timestamps. uperf-postprocess is the
# only script that makes use of it.
gen_data(\%uperf_rate, \%graph_type, \%graph_threshold, $dir, 1);
