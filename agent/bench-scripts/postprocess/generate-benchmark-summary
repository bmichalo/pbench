#!/usr/bin/perl
#
# Author: Andrew Theurer
# This script will process csv result files from each benchmark iteration, generating
# a summary of all iterations in txt, csv, html, and json.
# 
# usage:
# $script <benchmark-name> <original_command> <benchmark-results-directory>

use strict;
use warnings;
use JSON;
use File::Basename;
use Data::Dumper;
my $script = basename($0);
my $benchmark_name = $ARGV[0];
my $orig_cmd = $ARGV[1];
my $benchmark_run_dir = $ARGV[2];
my %spacing;

opendir(my $dh, $benchmark_run_dir) || die "$script: could not open directory $benchmark_run_dir: $!\n";
my @dirs = readdir($dh);
my $iteration_dir;
my $line = "";
my $dir;
my %metrics;
my %iterations_by_num;
my %all_metric_names_by_type;
my $iter_num = $1;
my $iter_name = $2;
my @iterations;
# build a hash from all of the iteration results
foreach $dir ( @dirs) {
	$iteration_dir = $benchmark_run_dir . "/" . $dir;
	print "iteration dir: $iteration_dir\n";
	if ((-d $iteration_dir) && ($dir =~ /(\d+)-(.+)/)) {
		$iter_num = $1;
		$iter_name = $2;
		my $length;
		# collect spcing info for output later
		$length = scalar split("", $iter_num);
		if (  ! defined $spacing{iter_num} || $spacing{iter_num} < $length ) {
			$spacing{iter_num} = $length;
		}
		$length = scalar split("", $iter_name);
		if ( ! defined $spacing{iter_name} || $spacing{iter_name} < $length ) {
			$spacing{iter_name} = $length;
		}
		$iterations_by_num{$iter_num} = $iter_name;
		##my $result_csv_file = $iteration_dir . "/result.csv";
		my $result_json_file = $iteration_dir . "/result.json";
		##open(ITERATION_CSV, "$result_csv_file") || die "$script: could not open file $result_csv_file: $!\n";
		# each iteration needs to follow a specific csv format, for example:
		# metric_type,metric_name,average,stddev,closest-sample
		# Efficiency,Gb-sec/CPU-client:perf104,4.0629,0.5134,2
		# Efficiency,Gb-sec/CPU-server:perf102,4.5188,0.3804,3
		# Resource,CPU-client:perf104,0.2318,0.5274,2
		# Resource,CPU-server:perf102,0.2085,0.4279,3
		# Throughput,aggregate_Gb_sec,0.9415,0.0189,1
		# Throughput,server_perf104:21000_Gb_sec,0.9417,0.0255,1
		##$line = <ITERATION_CSV>; # first line contains labels: metric_type,metric_name,average,stddev,closest-sample
		##chomp $line;
		##my @labels = split(/,/, $line);
		##shift(@labels);
		##shift(@labels); # @labels should now contain only ("average", "stddevpct", "closest-sample")
		##while (<ITERATION_CSV>) {
			##$line = "$_";
			##chomp($line);
			##my $label;
			##my @values = split(/,/, $line);
			##my $metric_type = shift(@values); # Throughput, Latency, Resource, CPU
			##my $metric_name = shift(@values); # Gb_s, MB_s, trans_sec
			##$all_metric_names_by_type{$metric_type}{$metric_name}++;
			##foreach $label (@labels) {
				##$all_metric_labels{$label}++;
				##$metrics{$iter_name}{$metric_type}{$metric_name}{$label} = shift(@values)
			##}
		##}
		##close ITERATION_CSV;



		#{
		#   "parameters" : {
		#      "benchmark" : [
		#         {
		#            "acceptable_loss_pct" : "0.002000",
		#            "name" : "MoonGen",
		#            "validation_run_time" : "60",
		#            "frame_size" : "512",
		#            "description" : "Test parameters for MoonGen",
		#            "run_bidirec" : "false",
		#            "start_rate" : "2.349624",
		#            "search_run_time" : "60",
		#            "port_list" : "1,2",
		#            "role" : "packet-generator"
		#         }
		#      ]
		#   },
		#   "throughput" : {
		#      "Mframes_sec" : [
		#         {
		#            "samples" : [
		#               "2.349575",
		#               "2.349527",
		#               "2.349548"
		#            ],
		#            "samples-stddev" : 1.96468827044147e-05,
		#            "samples-stddevpct" : 0.000836197684850918,
		#            "samples-mean" : 2.34955,
		#            "samples-closest" : 3,
		#            "port" : "all",
		#            "description" : "The number of Ethernet frames (in millions) received per second"
		#         }
		#      ],
		#      "Gb_sec" : [
		#         {
		#            "samples" : [
		#               9.9997912,
		#               9.999586912,
		#               9.999676288
		#            ],
		#            "samples-stddev" : 8.36171327902283e-05,
		#            "samples-stddevpct" : 0.00083619768485331,
		#            "samples-mean" : 9.9996848,
		#            "samples-closest" : 3,
		#            "port" : "all",
		#            "description" : "The number of bits (in billions) received from Ethernet phsycial layer per second"
		#         }
		#}
		open(ITERATION_JSON, "$result_json_file") || die "$script: could not open file $result_json_file: $!\n";
		my $json_text;
                while ( <ITERATION_JSON> ) {
                        $json_text = $json_text . $_;
                        }
                close TXT;
                my $perl_scalar = from_json( $json_text, { utf8  => 1 } );
		#printf Dumper $perl_scalar;
                push @iterations, $perl_scalar;
	}
}
print "Iterations:\n";
print Dumper \@iterations;
my $json_text   = to_json( \@iterations, { ascii => 1, pretty => 1 } );
my $json_file = $benchmark_run_dir . "/result.json";
open(JSON, ">$json_file") || die "$script: could not open file $json_file: $!\n";
print JSON $json_text;
close(JSON);

my $iteration_name;
my $iteration_num;
my $metric_name;
my $metric_type;
my $metric_label;
my $length;
my $padding = 1;
my $i;
my $this_metric_type_name_spacing;
my %metric_labels;
my %metric_types;

# calculate spacing such that we have enough space for each column, but non extra (other than $padding)
foreach $iteration_num (sort keys %iterations_by_num) {
	$iteration_name = $iterations_by_num{$iteration_num};
	$length = scalar split("", $iteration_num) + $padding;
	if ( ! defined ($spacing{iter_num}) || $spacing{iter_num} < $length) {
		$spacing{iter_num} = $length;
	}
	$length = scalar split("", $iteration_name) + $padding;
	if ( ! defined ($spacing{iter_name}) || $spacing{iter_name} < $length) {
		$spacing{iter_name} = $length;
	}
	foreach $metric_type (keys %{ $iterations[$iteration_num-1] }) {  #parameters, throughput, resource, efficiency, latency
		$metric_types{$metric_type}++;
		my $this_metric_type_spacing = 0;
		foreach $metric_name (sort keys %{ $iterations[$iteration_num-1]{$metric_type} } ) { #Gb_sec, MB_sec, trans_sec, usec, Gb_sec_cpu
			$all_metric_names_by_type{$metric_type}{$metric_name}++;
			my $this_metric_type_name_spacing = 0;
			for ($i=0; $i < scalar @{$iterations[$iteration_num-1]{$metric_type}{$metric_name}}; $i++) {
				foreach $metric_label ( sort keys %{ $iterations[$iteration_num-1]{$metric_type}{$metric_name}[$i] } ) { #average, stddevpct, closest-sample
					if ( $metric_label eq "stddev" || $metric_label eq "stddevpct" || $metric_label eq "mean" || $metric_label eq "closest-sample" ) {
						#print "processing metric_label: $metric_label\n";
						$metric_labels{$metric_label}++;
						if ( defined $iterations[$iteration_num-1]{$metric_type}{$metric_name}[$i]{$metric_label} ) {
							if ( $metric_label ne "closest-sample" ) {
								# convert numbers to standard format
								$iterations[$iteration_num-1]{$metric_type}{$metric_name}[$i]{$metric_label} = sprintf("%.4f", $iterations[$iteration_num-1]{$metric_type}{$metric_name}[$i]{$metric_label});
							}
							$iterations[$iteration_num-1]{$metric_type}{$metric_name}[$i]{$metric_label} = sprintf("%s", $iterations[$iteration_num-1]{$metric_type}{$metric_name}[$i]{$metric_label});
							$length = scalar split("", $iterations[$iteration_num-1]{$metric_type}{$metric_name}[$i]{$metric_label}) + $padding;
							#printf "length for [ %s] is %d\n", $iterations[$iteration_num-1]{$metric_type}{$metric_name}[$i]{$metric_label}, $length;
							if ( ! defined $spacing{$metric_type}{$metric_name}{$metric_label} || $length > $spacing{$metric_type}{$metric_name}{$metric_label} ) {
								$spacing{$metric_type}{$metric_name}{$metric_label} = $length;
							}
						}
						# check to see if the name length of the label itself is longer than the longest label-value
						$length = scalar split("", $metric_label) + $padding;
						if ( ! defined $spacing{$metric_type}{$metric_name}{$metric_label} || $spacing{$metric_type}{$metric_name}{$metric_label} < $length) {
							$spacing{$metric_type}{$metric_name}{$metric_label} = $length;
						}
						# this_metric_type_name is calculated by summing metric label lengths
						$this_metric_type_name_spacing += $spacing{$metric_type}{$metric_name}{$metric_label};
					}
				
				}
			}
			$this_metric_type_name_spacing += $padding;
			# check to see if the spacing for this_metric_type_name is longer than existing spacing for metric_type_name:
			if ( ! defined $spacing{$metric_type}{$metric_name}{header} || $spacing{$metric_type}{$metric_name}{header} < $this_metric_type_name_spacing) {
				$spacing{$metric_type}{$metric_name}{header} = $this_metric_type_name_spacing;
			}
			# check to see if the name length of the metric_name itself is longer than the metric values
			$length = scalar split("", $metric_name) + $padding;
			if ( $spacing{$metric_type}{$metric_name}{header} < $length) {
				$spacing{$metric_type}{$metric_name}{header} = $length;
			}
			# get the metric type header by summing the metric name lengths
			$this_metric_type_spacing += $spacing{$metric_type}{$metric_name}{header};
		}
		$this_metric_type_spacing += $padding;
		# check to see if this_metric_type_spacing is longer than existing metric type spacing
		if ( ! defined $spacing{$metric_type}{header} || $spacing{$metric_type}{header} < $this_metric_type_spacing) {
			$spacing{$metric_type}{header} = $this_metric_type_spacing;
		}
		# check to see if the name length of the metric type itself is longer than the metric type values
		$length = scalar split("", $metric_type) + $padding;
		if ( $spacing{$metric_type}{header} < $length) {
			$spacing{$metric_type}{header} = $length;
		}
	}
}

print Dumper \%spacing;

if (0 == 0) {

# generate all of the summary files
my $txt_file = $benchmark_run_dir . "/result.txt";
my $csv_file = $benchmark_run_dir . "/result.csv";
my $html_file = $benchmark_run_dir . "/result.html";
open(TXT, ">$txt_file") || die "$script: could not open file $txt_file: $!\n";
open(CSV, ">$csv_file") || die "$script: could not open file $csv_file: $!\n";
open(HTML, ">$html_file") || die "$script: could not open file $html_file: $!\n";
print HTML "<!DOCTYPE html>\n<html>\n<head>\n<title>HTML Tables</title>\n</head>\n<body>\n\n<table cellpadding=\"6\" border=\"1\" style=\"border: 1pt solid #000000; border-Collapse: collapse\">\n";

$iteration_name = $iterations_by_num{"1"};
##my @all_metric_types = reverse sort keys %all_metric_names_by_type;
my @all_metric_types = (keys %metric_types);
my @all_metric_labels = (keys %metric_labels);

# print the headers for metric types (Throuhgput, Resource, Efficiency)
printf TXT "%$spacing{iter_num}s%$spacing{iter_name}s", "", "";
printf HTML "<tr><td>%s</td><td>%s</td>", "", "";
foreach $metric_type (@all_metric_types) {
	if ($metric_type eq "parameters" ) {
		next;
	}
	my $colspan = (scalar @all_metric_labels) * ( scalar keys %{ $all_metric_names_by_type{$metric_type} } );
	$length = scalar split("", $metric_type);
	if ( $length + $padding > $spacing{$metric_type}{header} ) {
		printf "warning: length of $metric_type (%d) is longer than spacing for $metric_type header (%s)\n", $length, $spacing{$metric_type}{header};
	}
	printf TXT "%$spacing{$metric_type}{header}s|", $metric_type;
	printf HTML "<th colspan=$colspan><div align=\"center\">%s</div></th>", "$metric_type";
}
printf TXT "\n";
printf HTML "</tr>\n";

# print the headers for individual metrics in each metric type (aggregate_Gb_sec)
# [TXT, HTML] first some spacing for interation num and name columns
printf TXT "%$spacing{iter_num}s%$spacing{iter_name}s", "", "";
printf HTML "<tr><td>%s</td><td>%s</td>", "", "";
# [CSV] first two headers for interation num & name
printf CSV "%s,%s,", "iteration-number", "iteration-name";
# then print the headers for individual metrics
foreach $metric_type (@all_metric_types) {
	if ($metric_type eq "parameters" ) {
		next;
	}
	my $metric_section;
	my $csv_metric_section;
	my $colspan = scalar @all_metric_labels;
	foreach $metric_name (sort keys %{ $all_metric_names_by_type{$metric_type} } ) {
		$metric_section = $metric_section . sprintf "%$spacing{$metric_type}{$metric_name}{header}s", $metric_name;
		$csv_metric_section = $csv_metric_section . sprintf "%s,", $metric_name;
		printf HTML "<td colspan=$colspan><div align=\"center\">%s</div></td>", $metric_name;
	}
	$length = scalar split("", $metric_section);
	if ( $length + $padding > $spacing{$metric_type}{header} ) {
		printf "warning: length of $metric_section (%d) is longer than spacing for $metric_type header (%s)\n", $length, $spacing{$metric_type}{header};
	}
	printf TXT "%$spacing{$metric_type}{header}s|", $metric_section;
	printf CSV "%s", $csv_metric_section;
	#printf HTML "<td>%s</td>", $metric_section;
}
printf TXT "\n";
printf CSV "\n";
printf HTML "<tr>\n";

# print a horizontal separator 
printf TXT "%$spacing{iter_num}s%$spacing{iter_name}s", "", "";
printf HTML "%$spacing{iter_num}s%$spacing{iter_name}s", "", "";
foreach $metric_type (@all_metric_types) {
	if ($metric_type eq "parameters" ) {
		next;
	}
	my $metric_section;
	foreach $metric_name (sort keys %{ $all_metric_names_by_type{$metric_type} } ) {
		my $metric_underline = "";
		my $i;
		for ($i=0; $i<($spacing{$metric_type}{$metric_name}{header} - $padding); $i++) {
			$metric_underline = $metric_underline . sprintf "%s", "-";
		}
		$metric_section = $metric_section . sprintf "%$spacing{$metric_type}{$metric_name}{header}s", $metric_underline;
	}
	$length = scalar split("", $metric_section);
	if ( $length + $padding > $spacing{$metric_type}{header} ) {
		printf "warning: length of $metric_section (%d) is longer than spacing for $metric_type header (%s)\n", $length, $spacing{$metric_type}{header};
	}
	printf TXT "%$spacing{$metric_type}{header}s+", $metric_section;
	#printf HTML "%$spacing{$metric_type}{header}s+", $metric_section;
}
printf TXT "\n";
#printf HTML "\n";

# print the headers for the metric-labels (average, stddev, closest-sample)
$iteration_num = 1;
$iteration_name = $iterations_by_num{$iteration_num};
printf TXT "%$spacing{iter_num}s%$spacing{iter_name}s", "", "";
printf HTML "<tr><td>%s</td><td>%s</td>", "", "";
foreach $metric_type (@all_metric_types) {
	if ($metric_type eq "parameters" ) {
		next;
	}
	my $metric_section;
	foreach $metric_name (sort keys %{ $all_metric_names_by_type{$metric_type} } ) {
		my $label_section = "";
		foreach $metric_label ( @all_metric_labels ) {
			#if ( defined ($metrics{$iteration_name}{$metric_type}{$metric_name}{$metric_label}) ) {
				$label_section = $label_section . sprintf "%$spacing{$metric_type}{$metric_name}{$metric_label}s", "$metric_label";
			#} else {
			#	$label_section = $label_section . sprintf "%$spacing{$metric_type}{$metric_name}{$metric_label}s", "$metric_label";
			#}
			printf HTML "<td>%s</td>", $metric_label;
		}
		$length = scalar split("", $label_section);
		if ( $length + $padding > $spacing{$metric_type}{$metric_name}{header} ) {
			printf "warning: length of [%s] (%d) is longer than spacing for [%s] header (%s)\n", $label_section, $length, $metric_name, $spacing{$metric_type}{$metric_name}{header};
		}
		$metric_section = $metric_section . sprintf "%$spacing{$metric_type}{$metric_name}{header}s", $label_section;
	}
	$length = scalar split("", $metric_section);
	if ( $length + $padding > $spacing{$metric_type}{header} ) {
		printf "warning: length of $metric_section (%d) is longer than spacing for $metric_type header (%s)\n", $length, $spacing{$metric_type}{header};
	}
	printf TXT "%$spacing{$metric_type}{header}s|", $metric_section;
	#printf HTML "<td>%s</td>", $metric_section;
}
printf TXT "\n";
printf HTML "</tr>\n";

# for all iterations, print the *values* for the metric labels (average, stddev, closest-sample)
foreach $iteration_num (sort keys %iterations_by_num) {
	$iteration_name = $iterations_by_num{$iteration_num};
	printf TXT "%$spacing{iter_num}s%$spacing{iter_name}s", $iteration_num, $iteration_name;
	printf CSV "%s,%s,", $iteration_num, $iteration_name;
	my $href_spacing = $spacing{iter_name} - (scalar split("", $iteration_name));
	printf HTML "<tr><td>%s</td><td>%s</td>", $iteration_num, "<a href=./$iteration_num-$iteration_name>$iteration_name</a>";
	#printf HTML "%$spacing{iter_num}s%$spacing{iter_name}s", $iteration_num, "<a href=./$iteration_num-$iteration_name>$iteration_name</a>";
	#printf HTML "%$spacing{iter_num}s<a href=./%s-%s>%$spacing{iter_name}s</a>", $iteration_num, $iteration_num, $iteration_name, $iteration_name;
	foreach $metric_type (@all_metric_types) {
		if ($metric_type eq "parameters" ) {
			next;
		}
		my $metric_section;
		my $csv_metric_section = "";
		foreach $metric_name (sort keys %{ $all_metric_names_by_type{$metric_type} } ) {
			my $label_section = "";
			my $csv_label_section = "";
			foreach $metric_label ( @all_metric_labels ) {
				if ( $metric_label eq "stddev" || $metric_label eq "stddevpct" || $metric_label eq "mean" || $metric_label eq "closest-sample" ) {
					if ( defined ($iterations[$iteration_num-1]{$metric_type}{$metric_name}[0]{$metric_label}) ) {
						my $metric_label_string;
						$metric_label_string = sprintf "%$spacing{$metric_type}{$metric_name}{$metric_label}s", $iterations[$iteration_num-1]{$metric_type}{$metric_name}[0]{$metric_label};
						if ( $metric_label eq "closest-sample" ) { # embed a link to the closest sample
							#printf HTML "<td><div align=\"right\"><a href=\"./$iteration_num-$iteration_name/sample$iterations[$iteration_num-1]{$metric_type}{$metric_name}[0]{$metric_label}\">$iterations[$iteration_num-1]}{$metric_type}{$metric_name}[0]{$metric_label}</a></dev></td>";
							printf HTML "<td><div align=\"right\"><a href=\"./$iteration_num-$iteration_name/sample$iterations[$iteration_num-1]{$metric_type}{$metric_name}[0]{$metric_label}\">$metric_label_string</a></dev></td>";
						} else {
							#printf HTML "<td><div align=\"right\">$iteration_num-1]{$metric_type}{$metric_name}[0]{$metric_label}</dev></td>";
							printf HTML "<td><div align=\"right\">$metric_label_string</dev></td>";
						}
						$length = scalar split("", $metric_label_string);
						if ( $length > $spacing{$metric_type}{$metric_name}{$metric_label} ) {
							printf "warning: length of [%s] (%d) is longer than spacing for [%s] header (%s)\n", $metric_label_string, $length + $padding, $metric_label, $spacing{$metric_type}{$metric_name}{$metric_label};
						}
						$label_section = $label_section . sprintf "%$spacing{$metric_type}{$metric_name}{$metric_label}s", "$metric_label_string";
						if ( $metric_label eq "average" ) {
							$csv_label_section = sprintf "%s,", "$metric_label_string";
						}
					} else {
						printf HTML "<td></td>";
						printf "$metric_type $metric_name $metric_label\n";
						$label_section = $label_section . sprintf "%$spacing{$metric_type}{$metric_name}{$metric_label}s", "";
						if ( $metric_label eq "average" ) {
							$csv_label_section = $csv_label_section = sprintf "%s,", "";
						}
					}
				}
			}
			$length = scalar split("", $label_section);
			if ( $length + $padding > $spacing{$metric_type}{$metric_name}{header} ) {
				printf "warning: length of [%s] (%d) is longer than spacing for [%s] header (%s)\n", $label_section, $length, $metric_name, $spacing{$metric_type}{$metric_name}{header};
			}
			$metric_section = $metric_section . sprintf "%$spacing{$metric_type}{$metric_name}{header}s", $label_section;
			$csv_metric_section = $csv_metric_section . sprintf "%s", $csv_label_section;
		}
		$length = scalar split("", $metric_section);
		if ( $length + $padding > $spacing{$metric_type}{header} ) {
			printf "warning: length of $metric_section (%d) is longer than spacing for $metric_type header (%s)\n", $length, $spacing{$metric_type}{header};
		}
		printf TXT "%$spacing{$metric_type}{header}s|", $metric_section;
		printf CSV "%s", $csv_metric_section;
		#printf HTML "%$spacing{$metric_type}{header}s|", $metric_section;
	}
	printf TXT "\n";
	printf CSV "\n";
	printf HTML "</tr>\n";
}
printf TXT "\n";
printf CSV "\n";
printf HTML "\n</table>\n\n</body>\n</html>\n";
close(TXT);
close(CSV);
close(HTML);
}
